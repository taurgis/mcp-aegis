description: "Failing Complex Combination Tests - Demonstrates Multiple Pattern Combination Failures"
tests:
  # These tests should fail to demonstrate complex pattern combination error detection

  # Test 1: Complex array elements with multiple pattern failures
  - it: "should fail when complex array elements validation fails"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-1"
      method: "tools/list"
      params: {}
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-1"
        result:
          tools:
            match:arrayElements:
              name: "match:regex:^delete_"      # ❌ FAIL: "read_file" doesn't start with "delete_"
              description: "match:contains:remove"  # ❌ FAIL: description doesn't contain "remove"
              inputSchema:
                type: "match:type:array"        # ❌ FAIL: inputSchema.type is "object", not "array"

  # Test 2: Field extraction with complex pattern validation failure
  - it: "should fail when field extraction with complex validation fails"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-2"
      method: "tools/list"
      params: {}
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-2"
        result:
          match:extractField: "tools.*.name"
          value:
            match:arrayElements: "match:startsWith:create_"  # ❌ FAIL: ["read_file"] doesn't start with "create_"

  # Test 3: Partial matching with nested pattern failures
  - it: "should fail when partial matching with nested patterns fails"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-3"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-3"
        result:
          match:partial:
            content:
              match:arrayElements:
                type: "match:type:number"       # ❌ FAIL: type is "text" (string), not number
                text: "match:regex:^\\d+$"      # ❌ FAIL: "Hello world!" is not numeric
            isError: "match:not:type:boolean"   # ❌ FAIL: isError IS boolean (negation fails)

  # Test 4: Multiple field extractions with different failures
  - it: "should fail when multiple field extractions fail differently"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-4"
      method: "tools/list"
      params: {}
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-4"
        result:
          # Extraction pattern container must ONLY contain match:extractField + value
          match:extractField: "tools.*.nonExistent"    # ❌ FAIL: field doesn't exist
          value: "match:arrayLength:3"                 # ❌ FAIL: if extraction worked, wrong length

  # Test 4b: Separate extraction to avoid structural mixing
  - it: "should fail when secondary extraction also fails (separated to avoid mixing)"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-4b"
      method: "tools/list"
      params: {}
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-4b"
        result:
          match:extractField: "tools.*.name"
          value: "match:arrayContains:delete_file"     # ❌ FAIL: no "delete_file" tool

  # Test 5: Negated complex patterns that should pass but fail
  - it: "should fail when negated complex patterns are incorrectly negated"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-5"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-5"
        result:
          content:
            match:not:arrayElements:
              type: "text"                      # ❌ FAIL: type IS "text", negation should fail

  # Test 6: Cross-field validation combined with other patterns
  - it: "should fail when cross-field validation combined with other patterns fails"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-6"
      method: "tools/call"
      params:
        name: "get_crossfield_data"
        arguments:
          dataset: "user_profile"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-6"
        result:
          match:crossField: "startDate:dateAfter:endDate"  # ❌ FAIL: wrong date order
          # Also test other patterns that should fail
          firstName: "match:length:1"                       # ❌ FAIL: firstName is longer than 1 char
          lastName: "match:type:number"                     # ❌ FAIL: lastName is string, not number

  # Test 7: Deeply nested partial matching with multiple failures
  - it: "should fail when deeply nested partial matching fails at multiple levels"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-7"
      method: "tools/list"
      params: {}
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-7"
        result:
          tools:
            - match:partial:
                inputSchema:
                  match:partial:
                    type: "array"               # ❌ FAIL: type is "object"
                    properties:
                      match:partial:
                        wrongField:             # ❌ FAIL: wrongField doesn't exist
                          type: "string"

  # Test 8: Array elements with partial matching and field extraction failures
  - it: "should fail when array elements with partial matching and extraction fails"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-8"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-8"
        result:
          content:
            match:arrayElements:
              match:partial:
                type: "image"                   # ❌ FAIL: type is "text", not "image"
                text: "match:contains:Goodbye"  # ❌ FAIL: text contains "Hello", not "Goodbye"

  # Test 8b: Split out the extraction failure from Test 8 (can't mix with arrayElements container)
  - it: "should fail when extraction on content elements looks for missing field"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-8b"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-8b"
        result:
          match:extractField: "content.*.nonExistent"   # ❌ FAIL: field doesn't exist
          value: ["something"]                          # ❌ FAIL: expected value wrong anyway

  # Test 9: Multiple date pattern failures in combination
  - it: "should fail when multiple date patterns fail in combination"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-9"
      method: "tools/call"
      params:
        name: "get_timestamp_data"
        arguments:
          format: "mixed"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-9"
        result:
          fixedDate: "match:dateAfter:2025-01-01"          # ❌ FAIL: 2023 date is before 2025
          isoDate: "match:dateFormat:timestamp"            # ❌ FAIL: ISO string, not timestamp
          invalidDate: "match:not:dateValid"               # ❌ FAIL: double negative - invalid IS invalid

  # Test 9b: Separate extraction of fixedDate to avoid mixing extraction container with direct fields
  - it: "should fail when extracting fixedDate with mismatching regex"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-9b"
      method: "tools/call"
      params:
        name: "get_timestamp_data"
        arguments:
          format: "mixed"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-9b"
        result:
          match:extractField: "fixedDate"
          value: "match:regex:^\\d{4}$"                   # ❌ FAIL: full date won't match year only

  # Test 10: Numeric patterns combined with type and array failures
  - it: "should fail when numeric patterns combined with other patterns fail"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-10"
      method: "tools/call"
      params:
        name: "get_numeric_data"
        arguments:
          dataset: "api"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-10"
        result:
          requestCount: "match:between:2000:3000"          # ❌ FAIL: 1250 is not between 2000-3000
          errorCount: "match:type:string"                  # ❌ FAIL: errorCount is number, not string

  # Test 10b: Treat entire result object incorrectly as an array (isolated to avoid mixing)
  - it: "should fail when treating numeric result object as array elements"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-10b"
      method: "tools/call"
      params:
        name: "get_numeric_data"
        arguments:
          dataset: "api"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-10b"
        result:
          match:arrayElements:
            activeUsers: "match:type:number"               # ❌ FAIL: result is object, not array

  # Test 11: String patterns with regex and length combinations that fail
  - it: "should fail when string patterns with complex combinations fail"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-11"
      method: "tools/list"
      params: {}
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-11"
        result:
          tools:
            - name: "match:regex:^create_\\w+$"           # ❌ FAIL: "read_file" doesn't match create_ pattern
              description: "match:length:100"             # ❌ FAIL: description is not 100 chars long
              inputSchema:
                type: "match:startsWith:arr"              # ❌ FAIL: "object" doesn't start with "arr"

  # Test 12: All pattern types failing together
  - it: "should fail when all major pattern types fail in combination"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-12"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-12"
        result:
          # Consolidated: use partial to validate multiple field failures without duplicate keys
          match:partial:
            content: "match:type:object"                  # ❌ FAIL: content is array, not object
            isError: "match:type:string"                  # ❌ FAIL: isError is boolean
            missingField: "someValue"                     # ❌ FAIL: field doesn't exist

  # Test 12b: Array element string failure isolated
  - it: "should fail when array element text does not contain expected substring"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-12b"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-12b"
        result:
          content:
            match:arrayElements:
              text: "match:contains:Goodbye"             # ❌ FAIL: contains Hello not Goodbye

  # Test 12c: Extraction failure isolated
  - it: "should fail when extracting missing field from content"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-12c"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-12c"
        result:
          match:extractField: "content.*.nonExistent"
          value: ["something"]                            # ❌ FAIL: field doesn't exist

  # Test 12d: Partial matching failure for wrong field isolated
  - it: "should fail when partial matching references non-existent field"
    request:
      jsonrpc: "2.0"
      id: "complex-fail-12d"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "complex-fail-12d"
        result:
          match:partial:
            wrongField: "value"                           # ❌ FAIL: field doesn't exist
