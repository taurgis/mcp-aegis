description: "Array Contains Field Matching Patterns - Testing object field validation in arrays with dot notation support"
tests:
  # Basic field matching tests (existing functionality)
  - it: "should find tool by name using arrayContains field matching"
    request: {jsonrpc: "2.0", id: "arraycontains-1", method: "tools/list", params: {}}
    expect:
      response:
        jsonrpc: "2.0"
        id: "arraycontains-1"
        result:
          tools: "match:arrayContains:name:read_file"
      stderr: "toBeEmpty"

  - it: "should find tool by description using arrayContains field matching"  
    request: {jsonrpc: "2.0", id: "arraycontains-2", method: "tools/list", params: {}}
    expect:
      response:
        jsonrpc: "2.0"
        id: "arraycontains-2"
        result:
          tools: "match:arrayContains:description:Reads a file"
      stderr: "toBeEmpty"

  - it: "should find tool that has inputSchema field using arrayContains field matching"
    request: {jsonrpc: "2.0", id: "arraycontains-3", method: "tools/list", params: {}}
    expect:
      response:
        jsonrpc: "2.0"
        id: "arraycontains-3"
        result:
          tools:
            match:arrayElements:
              name: "match:type:string"
              description: "match:type:string"
              inputSchema: "match:type:object"
      stderr: "toBeEmpty"

  # ðŸ†• Dot notation tests - single level
  - it: "should find tool by nested schema type using dot notation"
    request: {jsonrpc: "2.0", id: "dot-1", method: "tools/list", params: {}}
    expect:
      response:
        jsonrpc: "2.0"
        id: "dot-1"
        result:
          tools: "match:arrayContains:inputSchema.type:object"
      stderr: "toBeEmpty"

  - it: "should find tool by nested schema properties using dot notation"
    request: {jsonrpc: "2.0", id: "dot-2", method: "tools/list", params: {}}
    expect:
      response:
        jsonrpc: "2.0"
        id: "dot-2"
        result:
          tools:
            match:arrayElements:
              match:partial:
                inputSchema:
                  properties: "match:type:object"
      stderr: "toBeEmpty"

  # ðŸ†• Dot notation tests - testing with actual response structure
  - it: "should validate nested response structure with dot notation after tool call"
    request:
      jsonrpc: "2.0"
      id: "dot-3"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "dot-3"
        result:
          content: "match:arrayContains:type:text"
          isError: false
      stderr: "toBeEmpty"

  # Negation tests with field matching
  - it: "should NOT find non-existent tool using arrayContains field matching"
    request: {jsonrpc: "2.0", id: "arraycontains-neg-1", method: "tools/list", params: {}}
    expect:
      response:
        jsonrpc: "2.0"
        id: "arraycontains-neg-1"
        result:
          tools: "match:not:arrayContains:name:non_existent_tool"
      stderr: "toBeEmpty"

  - it: "should NOT find tool with wrong description using arrayContains field matching"
    request: {jsonrpc: "2.0", id: "arraycontains-neg-2", method: "tools/list", params: {}}
    expect:
      response:
        jsonrpc: "2.0"
        id: "arraycontains-neg-2"
        result:
          tools: "match:not:arrayContains:description:This tool does not exist"
      stderr: "toBeEmpty"

  # ðŸ†• Dot notation with negation
  - it: "should NOT find tool by non-existent nested field with dot notation"
    request: {jsonrpc: "2.0", id: "dot-neg-1", method: "tools/list", params: {}}
    expect:
      response:
        jsonrpc: "2.0"
        id: "dot-neg-1"
        result:
          tools: "match:not:arrayContains:metadata.status:disabled"
      stderr: "toBeEmpty"

  # Traditional arrayContains compatibility test  
  - it: "should work with traditional arrayContains simple value matching"
    request:
      jsonrpc: "2.0"
      id: "arraycontains-simple"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/hello.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "arraycontains-simple"
        result:
          match:extractField: "content.*.type"
          value: "match:arrayContains:text"
      stderr: "toBeEmpty"

  # Error response validation with field matching
  - it: "should validate error response structure with arrayContains field matching"
    request:
      jsonrpc: "2.0"
      id: "arraycontains-error"
      method: "tools/call"
      params:
        name: "read_file"
        arguments:
          path: "../shared-test-data/nonexistent.txt"
    expect:
      response:
        jsonrpc: "2.0"
        id: "arraycontains-error"
        result:
          content: "match:arrayContains:type:text"
          isError: true
      stderr: "toBeEmpty"

  # Complex validation with multiple fields
  - it: "should validate multiple field conditions using arrayContains field matching"
    request: {jsonrpc: "2.0", id: "arraycontains-multi", method: "tools/list", params: {}}
    expect:
      response:
        jsonrpc: "2.0"
        id: "arraycontains-multi"
        result:
          tools:
            match:arrayElements:
              name: "match:type:string"
              description: "match:type:string"
              inputSchema: "match:type:object"
      stderr: "toBeEmpty"
